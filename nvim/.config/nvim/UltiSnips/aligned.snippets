global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def comment(): 
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')") 
	return x != '0' and y != '0'

def not_in(right_delimiter, left_delimiter):
    row, col = vim.current.window.cursor
    # get all lines up to the cursor
    # lines = vim.current.buffer[:row-1] + [vim.current.line[:col]]
    lines = [vim.current.line[:col]]

    open_delimiter = 0
    close_delimiter = 0

    for line in lines:
        open_delimiter += line.count(right_delimiter)
        close_delimiter += line.count(left_delimiter)

    # if there is at least one unmatched '(', we are inside a function
    return (open_delimiter - close_delimiter) <= 0

def line_above_ends_with_double_backslash():
    row, col = vim.current.window.cursor
    if row <= 1:  # No line above the first line
        return False
    line_above = vim.current.buffer[row - 2]  # 0-based index
    return line_above.rstrip().endswith("\\\\") or ('align' in line_above) or (in_normal_mode())

def ends_on_begin_env():
    pattern = r'\\begin\{\s*[^}]+\s*\}$'  # matches \begin{something}
    row, col = vim.current.window.cursor
    if row <= 1:  # No line above the first line
        return False
    line_above = vim.current.buffer[row - 2]  # 0-based index
    return bool(re.search(pattern, line_above))

def align_condition():
	return (env('align*') or env('align')) and not_in('{','}') and not_in('[',']') and not_in('(',')') and (not env('cases'))

def in_normal_mode():
    # vim.eval('mode()') returns the current mode as a string
    return vim.eval('mode()') == 'n'

def find_last_unbracketed_operator(s, operators):
    stack = []
    brackets = {'{': '}', '[': ']', '(': ')'}
    last_pos = -1
    last_op = None
    
    i = 0
    while i < len(s):
        char = s[i]
        
        # Handle opening brackets
        if char in brackets:
            stack.append(brackets[char])
        
        # Handle closing brackets
        elif char in brackets.values():
            if stack and stack[-1] == char:
                stack.pop()
        
        # Check if any operator matches at position i
        else:
            for op in operators:
                if s.startswith(op, i) and not stack:
                    last_pos = i
                    last_op = op
                    break  # Found operator, no need to check smaller operators
            
            # If an operator was found, skip ahead
            if last_op and i == last_pos:
                i += len(last_op) - 1
        
        i += 1

    return last_pos, last_op

endglobal

context "not line_above_ends_with_double_backslash() and env('align*') and (not ends_on_begin_env())"
snippet `(^\s*\S)` "Break line in aligned/ add \\ to the end of equation in aligned" rA
`!p
row, col = vim.current.window.cursor
if row > 1:  # No line above the first line
	# Get the line above (0-based indexing)
	line_above = vim.current.buffer[row - 2]
	# Append two backslashes if not already there
	if not line_above.endswith("\\\\"):
		vim.current.buffer[row - 2] = line_above + " \\\\"
snip.rv = match.group(1)
`
endsnippet

priority 200000
context "align_condition()"
snippet '^(\s*)je'  "Equal align beggining of the line" Ar
`!p snip.rv=match.group(1)`=&\ $0
endsnippet

priority 200000
context "align_condition()"
snippet '^((?!.*&).*\S)(\s*)je'  "Equal align" iAr
`!p snip.rv=match.group(1)` =&\ $0
endsnippet

priority 1000
context "align_condition()"
snippet '(leq|lq)'  "Leq align beggining of the line" Arb
\leq&\ $0
endsnippet

priority 20000
context "align_condition()"
snippet '^((?!.*&).*\S)(\s*)(leq|lq)'  "Leq align" iAr
`!p snip.rv=match.group(1)` \leq&\ $0
endsnippet

priority 200000
context "align_condition()"
snippet '(geq|gq)'  "Geq align beggining of the line" Arb
\geq&\ $0
endsnippet

priority 200000
context "align_condition()"
snippet '^((?!.*&).*\S)(\s*)(geq|gq)'  "geq align" iAr
`!p snip.rv=match.group(1)` \geq&\ $0
endsnippet

priority 200000
context "align_condition()"
snippet 'prop'  "Propto align beggining of the line" Arb
\propto&\ $0
endsnippet

priority 200000
context "align_condition()"
snippet '^((?!.*&).*\S)(\s*)prop'  "prop align" iAr
`!p snip.rv=match.group(1)` \propto&\ $0
endsnippet

priority 200000
context "align_condition()"
snippet '^(\s*)>'  "> align beggining of the line" Ar
`!p snip.rv=match.group(1)`>&\ $0
endsnippet

priority 200000
context "align_condition()"
snippet '^((?!.*&).*\S)(\s*)>'  "> align" iAr
`!p snip.rv=match.group(1)` >&\ $0
endsnippet

priority 200
context "align_condition()"
snippet '^(\s*)<'  "< align beggining of the line" Ar
`!p snip.rv=match.group(1)`<&\ $0
endsnippet

priority 200
context "align_condition()"
snippet '^((?!.*&).*\S)(\s*)<'  "< align" iAr
`!p snip.rv=match.group(1)` <&\ $0
endsnippet

priority 200
context "align_condition()"
snippet '^(\s*)jp'  "Plus align beggining of the line" Ar
`!p snip.rv=match.group(1)`&+ $0
endsnippet

priority 200
context "align_condition()"
snippet '^(\s*)jm'  "Plus align beggining of the line" Ar
`!p snip.rv=match.group(1)`&- $0
endsnippet

priority 20000
context "align_condition()"
snippet AA "For all in aligned" A
\quad \forall \ $0
endsnippet

priority 20000
context "align_condition()"
snippet EE "Exists in aligned" A
\quad \exists \ $0
endsnippet

context "env('cases')"
snippet `\sif` "if in cases" Ar
 \ \text{if} \ $0
endsnippet

context "env('cases')"
snippet `\sother` "otherwise in cases" Ar
 \ \text{otherwise} $0
endsnippet

context "math() and not_in('{','}')"
snippet `(\s*(.*)\s?(=|\\leq|\\geq|\\approx|<|>|\\propto|\\implies)&?\\?\s)\s*` "Repeat/copy what's before = after it" r
`!p
before_equal = match.group(2)
if set(before_equal).issubset({" "}) and (env('aligned') or env('align') or env('align*')):
    # Extract the line above the cursor
    row, col = vim.current.window.cursor
    if row > 1:
        line_above = vim.current.buffer[row - 2]
        line_above = line_above.strip()
        if line_above.endswith("\\\\"):
            line_above = line_above[:-2].rstrip()
        before_equal = line_above
else:
    open_del_idx = before_equal.rfind("\\(")
    if open_del_idx >= 0:
	    before_equal = before_equal[open_del_idx+2:]
if match.group(3) != "\implies":
    equal_idx, operator = find_last_unbracketed_operator(before_equal, ["=", "\\leq", "\\geq", "\\approx", "<", ">", "\\propto"])
    if operator and operator.startswith("\\"):
        equal_idx += len(operator) - 1
    before_equal = before_equal[equal_idx+1:]
else:
    implies_idx = before_equal.rfind("\\implies")
    if implies_idx > 0:
        before_equal = before_equal[implies_idx+8:]
    if "\\implies" not in before_equal and "&" in before_equal:
        before_equal = before_equal.replace("&\\", "")
        before_equal = before_equal.replace("&", "")
if before_equal.startswith("&\ "):
    before_equal = before_equal[3:]
elif before_equal.startswith("& "):
    before_equal = before_equal[2:]
elif before_equal.startswith("&"):
    before_equal = before_equal[1:]
elif before_equal.startswith(" "):
    before_equal = before_equal[1:]
snip.rv = match.group(1) + before_equal
`
endsnippet

