global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def comment(): 
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')") 
	return x != '0' and y != '0'

def not_in(right_delimiter, left_delimiter):
    row, col = vim.current.window.cursor
    # get all lines up to the cursor
    # lines = vim.current.buffer[:row-1] + [vim.current.line[:col]]
    lines = [vim.current.line[:col]]

    open_delimiter = 0
    close_delimiter = 0

    for line in lines:
        open_delimiter += line.count(right_delimiter)
        close_delimiter += line.count(left_delimiter)

    # if there is at least one unmatched '(', we are inside a function
    return (open_delimiter - close_delimiter) <= 0

def find_single_fraction(s):
    i = s.find(r'\frac')
    if i == -1:
        return None  # No \frac found
    i += 5  # Skip past '\frac'
    
    if i >= len(s) or s[i] != '{':
        return None  # Not a valid \frac format
    
    num, next_i = extract_braces(s, i)
    if next_i >= len(s) or s[next_i] != '{':
        return None  # No denominator found
    
    den, final_i = extract_braces(s, next_i)
    return num, den


def extract_braces(s, start):
    """Extract content inside matching braces starting at index `start`."""
    assert s[start] == '{', "Expected '{' at the start"
    stack = 1
    i = start + 1
    while i < len(s) and stack > 0:
        if s[i] == '{':
            stack += 1
        elif s[i] == '}':
            stack -= 1
        i += 1
    return s[start+1:i-1], i

def has_unbracketed_plus(s):
    stack = []
    brackets = {'{': '}', '[': ']', '(': ')'}
    for char in s:
        if char in brackets:
            # Opening bracket: push its closing pair
            stack.append(brackets[char])
        elif char in brackets.values():
            # Closing bracket: pop from stack if matching
            if stack and stack[-1] == char:
                stack.pop()
            else:
                # Mismatched bracket – optional handling
                return False
        elif char == '+' or char == '-':
            # If stack is empty, plus is outside brackets
            if not stack:
                return True
    return False

endglobal



snippet -- "em dash" iA
—
endsnippet

context "math()"
snippet `(?<![\\a-zA-Z])quad` "Quad - spacement" rA
\quad $0
endsnippet

context "math()"
snippet `(?<!\\)by` "Justification" riA
\tag{By $1}$0
endsnippet

context "math()"
snippet and "and" wA
\quad \text{and} \quad $0
endsnippet

context "math()"
snippet for "for" wA
\quad \text{for} \ $0
endsnippet

context "math()"
snippet `->|(?<![\\\w])to` "to" Ar
\to $0
endsnippet

context "math()"
snippet `->|(?<![\\\w])mto` "to" Ar
\mapsto $0
endsnippet

context "math()"
snippet `<-|(?<!\\)gets` "gets" Ar
\gets $0
endsnippet

context "math()"
snippet `(~|(?<![\\\w])sim)` "sim" Ar
\sim $0
endsnippet

context "math()"
snippet `(?<![\\\w])not` "not" Ar
\not $0
endsnippet

context "math()"
snippet `(?<![\\\w])neq` "not equal" Ar
\not = $0
endsnippet

context "math()"
snippet `(\s?)tp` "transpose" iAr
^\top`!p
if t[0] and t[0][0] not in [',', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

snippet eqref "Reference" iw
\eqref{${1:label}} $0
endsnippet

snippet ref "Reference" iw
\ref{${1:label}} $0
endsnippet

snippet label "Label" i
\label{${1:label}} $0
endsnippet

######### Probability #########
snippet wp "with probability" i
with probability at least \(1 - ${1:delta}\)$0
endsnippet

###############################

context "math()"
snippet `(\w|\d)\.\.(\w|\d)` "Sequence" iAr
${1:x}_`!p snip.rv = match.group(1)`, \ldots, $1_`!p snip.rv = match.group(2)` $0
endsnippet

context "math()"
snippet ja "Open sequence block" wA
[SEQ] ${1:${VISUAL}} [SEQ]$0
endsnippet

context "math()"
snippet `\[SEQ\]\s(.*)\s\[SEQ\]([^\{])([^\{])([^\{])` "Open sequence block" Ar
`!p
pattern = match.group(1)
idx1 = match.group(2)
operator = " " + match.group(3) + " "
idx2 = match.group(4)
term1 = pattern.replace("id", idx1)
try:
    inter_idx = str(eval(idx1+"+1"))
except(NameError, SyntaxError):
    inter_idx = idx1+"+1"
inter_term = pattern.replace("id", inter_idx)
term2 = pattern.replace("id", idx2)
snip.rv = term1 + operator + inter_term + operator + "\ldots" + operator + term2
`
endsnippet

context "math()"
snippet seq "Open sequence block" wA
[SEQ] ${1:${VISUAL}} [SEQ]{$2}{$3}{$4}$0
endsnippet

context "math()"
snippet `\[SEQ\]\\` "Open sequence block" rA
[SEQ]{$1}{$2}{$3}$0
endsnippet

context "math()"
snippet `\[SEQ\]\s(.*)\s\[SEQ\]\{([^\{\}]*)\}\{([^\{\}]*)\}\{([^\{\}]*)\}` "Open sequence block" Ar
`!p
pattern = match.group(1)
idx1 = match.group(2)
operator = " " + match.group(3) + " "
idx2 = match.group(4)
term1 = pattern.replace("id", idx1)
try:
    inter_idx = str(eval(idx1+"+1"))
except(NameError, SyntaxError):
    inter_idx = idx1+"+1"
inter_term = pattern.replace("id", inter_idx)
term2 = pattern.replace("id", idx2)
snip.rv = term1 + operator + inter_term + operator + "\ldots" + operator + term2
`
endsnippet

context "math()"
snippet under "Underbrace" iA
\underbrace{${1:${VISUAL}}}_{${2:= 0}}$0
endsnippet

context "math()"
snippet stack "Stack Expressions" iA
\stackrel{${1:label}}{${2:${VISUAL}}}$0
endsnippet

context "math()"
snippet can "Cancel Expressions" iA
\cancel{${1:${VISUAL}}}$0
endsnippet

snippet input "Input" bA
\input{${1:filename}}$0
endsnippet

snippet rext "Import external .R script" bA
\Rexternal{./${1:filename}.R}
endsnippet

snippet `(^\s*\\codeoutput\{(.*)\})` "Execute code and save output in a .log file and import to latex" rA
`!p 
from pathlib import Path
raw_path = match.group(2)
script_path = Path(raw_path)
if script_path.exists():
    if script_path.suffix in [".r", ".R"]:
        os.system(f"Rscript {raw_path} > {raw_path}.log")
        snip.rv = match.group(1)
    elif script_path.suffix == ".py":
        os.system(f"python3 {raw_path} > {raw_path}.log")
        snip.rv = match.group(1)
    else:
        snip.rv = match.group(1) + " % Error: File suffix not implemented"
else:
    snip.rv = match.group(1) + " % Error: script's path don't exist."
`
endsnippet


snippet warning "Warning sign" w
\warning{${1:${VISUAL}}}
endsnippet

snippet info "info sign" w
\info{${1:${VISUAL}}}
endsnippet

snippet Info "info sign" w
\info{${1:${VISUAL}}}
endsnippet

snippet Warning "Warning sign" w
\warning{${1:${VISUAL}}}
endsnippet

snippet attention "Warning sign" w
\warning{${1:${VISUAL}}}
endsnippet

snippet `(\\frac{(.*)}{(.*)})\s?fj` "Change fraction from a/b to 1/b a" Ar
`!p
expr = match.group(1)
num, dem = find_single_fraction(expr)
if has_unbracketed_plus(num):
    snip.rv = "\\frac{1}{" + dem + "} \\left(" + num + "\\right )"
else:
    snip.rv = "\\frac{1}{" + dem + "} " + num
`
endsnippet
