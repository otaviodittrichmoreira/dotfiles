global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def comment(): 
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')") 
	return x != '0' and y != '0'

endglobal
snippet -- "em dash" iA
â€”
endsnippet

context "math()"
snippet `(?<![\a-zA-Z])quad` "Quad - spacement" rA
\quad $0
endsnippet

context "math()"
snippet `(?<!\\)by` "Justification" riA
 \quad \text{(By $1)}$0
endsnippet

context "math()"
snippet and "and" wA
\quad \text{and} \quad $0
endsnippet

context "math()"
snippet `->|(?<!\\)to` "to" Ar
\to $0
endsnippet

context "math()"
snippet `<-|(?<!\\)gets` "gets" Ar
\gets $0
endsnippet

context "math()"
snippet `(~|(?<![\\\w])sim)` "sim" Ar
\sim $0
endsnippet

context "math()"
snippet `(?<![\\\w])not` "not" Ar
\not $0
endsnippet

context "math()"
snippet `(\s?)tp` "transpose" iAr
^\top`!p
if t[0] and t[0][0] not in [',', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

snippet eqref "Reference" iw
\eqref{${1:label}} $0
endsnippet

snippet ref "Reference" iw
\ref{${1:label}} $0
endsnippet

snippet label "Label" i
\label{${1:label}} $0
endsnippet

######### Probability #########
snippet wp "with probability" i
with probability at least \(1 - ${1:delta}\)$0
endsnippet

###############################

context "math()"
snippet `(\w|\d)\.\.(\w|\d)` "Sequence" iAr
${1:x}_`!p snip.rv = match.group(1)`, \ldots, $1_`!p snip.rv = match.group(2)` $0
endsnippet

context "math()"
snippet ja "Open sequence block" wA
[SEQ] ${1:${VISUAL}} [SEQ]$0
endsnippet

context "math()"
snippet `\[SEQ\]\s(.*)\s\[SEQ\]([^\{])([^\{])([^\{])` "Open sequence block" Ar
`!p
pattern = match.group(1)
idx1 = match.group(2)
operator = " " + match.group(3) + " "
idx2 = match.group(4)
term1 = pattern.replace("id", idx1)
try:
    inter_idx = str(eval(idx1+"+1"))
except(NameError, SyntaxError):
    inter_idx = idx1+"+1"
inter_term = pattern.replace("id", inter_idx)
term2 = pattern.replace("id", idx2)
snip.rv = term1 + operator + inter_term + operator + "\ldots" + operator + term2
`
endsnippet

context "math()"
snippet seq "Open sequence block" wA
[SEQ] ${1:${VISUAL}} [SEQ]{$2}{$3}{$4}$0
endsnippet

context "math()"
snippet `\[SEQ\]\\` "Open sequence block" rA
[SEQ]{$1}{$2}{$3}$0
endsnippet

context "math()"
snippet `\[SEQ\]\s(.*)\s\[SEQ\]\{([^\{\}]*)\}\{([^\{\}]*)\}\{([^\{\}]*)\}` "Open sequence block" Ar
`!p
pattern = match.group(1)
idx1 = match.group(2)
operator = " " + match.group(3) + " "
idx2 = match.group(4)
term1 = pattern.replace("id", idx1)
try:
    inter_idx = str(eval(idx1+"+1"))
except(NameError, SyntaxError):
    inter_idx = idx1+"+1"
inter_term = pattern.replace("id", inter_idx)
term2 = pattern.replace("id", idx2)
snip.rv = term1 + operator + inter_term + operator + "\ldots" + operator + term2
`
endsnippet

context "math()"
snippet under "Underbrace" iA
\underbrace{${1:expression}}_{\text{${2:label}}}$0
endsnippet

snippet input "Input" bA
\input{${1:filename}}$0
endsnippet
