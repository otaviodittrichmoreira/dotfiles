global !p
def math():
	return vim.eval('vimtex#syntax#in_mathzone()') == '1'

def comment(): 
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')") 
	return x != '0' and y != '0'

endglobal


context "math()"
snippet `(\s?)jv` "subscript" iAr
_{${1:${VISUAL}}}`!p
if t[0] and t[0][0] not in [',', ' ', '/']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet


context "math()"
snippet '(\s*)je' "Equal Symbol" riA
 = $0
endsnippet

context "math()"
snippet `(?<!\\)\bsum` "sum" Ar
\sum_{$1} $0
endsnippet

context "math()"
snippet `(?<!\\)\bprod` "product" Ar
\prod_{$1} $0
endsnippet

priority 300
context "math()"
snippet '\\(prod|sum|cup|bigcup|cap|bigcap)_\{([^}]*)je' "equal in sum" Ar
`!p
snip.rv = '\\' + match.group(1) + "_{" + match.group(2)` = ${1:1}`!p snip.rv = "}^{"`${0:n}
endsnippet 

context "math()"
snippet `(?<![\\a-zA-Z])cup` "union" Ar
\cup 
endsnippet

context "math()"
snippet `(?<![\\a-zA-Z])Cup` "big union" Ar
\bigcup 
endsnippet

context "math()"
snippet `(?<![\\a-zA-Z])cap` "Intersection" Ar
\cap 
endsnippet

context "math()"
snippet `(?<![\\a-zA-Z])Cap` "Big intersection" Ar
\bigcap 
endsnippet

context "math()"
snippet UU "cup" iA
\cup 
endsnippet

context "math()"
snippet `(?<![\\\w])lim` "limit" r
\lim_{${1:n} \to ${2:\infty}} 
endsnippet

context "math()"
snippet `(?<![\\\w])limjv` "limit" rA
\lim_{${1:n} \to ${2:\infty}} 
endsnippet

context "math()"
snippet `(?<![\\\w])limsup` "limsup" rA
\limsup_{${1:n} \to ${2:\infty}} 
endsnippet

context "math()"
snippet `(?<![\\\w])liminf` "liminf" rA
\liminf_{${1:n} \to ${2:\infty}} 
endsnippet

snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

context "math()"
snippet '(\s*)jm' "Minus Symbol" riA
 - $0
endsnippet

context "math()"
snippet '(\s*)jp' "Plus Symbol" riA
 + $0
endsnippet

context "math()"
snippet '(\s*)js' "square" iAr
`!p
if t[0] and t[0][0] not in [',',' ','/']:
	rear = ' '
else:
	rear = ''
if snip.v.text is not None and len(snip.v.text) > 0:
	snip.rv = match.group(1) + "\left(" + snip.v.text + "\\right)^{2}" + rear
else:
	snip.rv = "^{2}" + rear
`$0 
endsnippet

context "math()"
snippet `(\s?)jr` "supscript" iAr
`!p
if snip.v.text is not None and len(snip.v.text) > 0:
	snip.rv = match.group(1) + "\left(" + snip.v.text + "\\right)"
else:
	snip.rv = ""
`^{$1}`!p
if t[0] and t[0][0] not in [',',' ','/']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

context "math()"
snippet jq "\sqrt{}" iA
\sqrt{${1:${VISUAL}}}`!p
if t[0] and t[0][0] not in [',',' ','/']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0 
endsnippet

context "math()"
snippet `(?<!\\)\b(lq|leq)` "Less than or equal to" Ar
\leq $0
endsnippet

context "math()"
snippet `(?<!\\)\b(gq|geq)` "Less than or equal to" Ar
\geq $0
endsnippet

priority 20000
context "math()"
snippet `>[&\s]?[\\]?\s*>` ">>" rA
\gg $0
endsnippet

priority 20000
context "math()"
snippet `<[&\s]?[\\]?\s*<` "<<" rA
\ll $0
endsnippet

context "math()"
snippet `(?<!\\)\bprop` "Less than or equal to" wAr
\propto $0
endsnippet

context "math()"
snippet `(?<!\\)\bapprox` "Greater than or equal to" wAr
\approx $0
endsnippet

priority 1
context "math()"
snippet `(\s*)<` "Smaller than (fix spacing)" Ar
 < $0
endsnippet

priority 1
context "math()"
snippet `(\s*)>` "Larger than (fix spacing)" Ar
 > $0
endsnippet

priority 100
context "math()"
snippet `->|(?<!\\)to` "to" A
\to $0
endsnippet

priority 100
context "math()"
snippet `<\s?->` "to" A
\leftrightarrow $0
endsnippet

########## Subscripts and Superscripts ##########
context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)``!p
if t[0] and t[0][0] not in [',', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '/']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}`!p
if t[0] and t[0][0] not in [',', ' ', '/']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

priority 2000000
context "math()"
snippet '\\([a|A]lpha|[b|B]eta|[g|G]amma|[d|D]elta|[e|E]psilon|[e|E]ta|[l|L]ambda|[m|M]u|[p|P]i|[s|S]igma|[t|T]heta|[o|O]mega|[z|Z]eta|[x|X]i|[r|R]ho|[n|N]u|[p|P]hi|[c|C]hi|[p|P]si|[t|T]au|[u|U]psilon|[k|K]appa|[i|I]ota)\s?(\d)' "auto subscript for greek letters" rA
`!p snip.rv = "\\" + match.group(1) + "_" + match.group(2)`
endsnippet

priority 20000000
context "math()"
snippet '(?<![\\\w])(\w)([ijknm])\s' "auto subscript ijkmn" rA
`!p snip.rv = match.group(1) + "_" + match.group(2) + " "`
endsnippet

# context "math()"
# snippet `(?<=\S)(\s*)(?<!\{)([a-zA-Z])\2` "auto subscript" wrA
# _{`!p snip.rv = match.group(2)`} $0
# endsnippet

########## Operators ##########
context "math()"
snippet op "operator" w
\operatorname{${1:${VISUAL}}} $0
endsnippet

context "math()"
snippet `\sargmin` "argmin" rwA
 \argmin $0
endsnippet

context "math()"
snippet `\smin` "min" rwA
 \min $0
endsnippet

context "math()"
snippet `\sargmax` "argmax" wAr
 \argmax $0
endsnippet

context "math()"
snippet `\smax` "max" wAr
 \max $0
endsnippet

context "math()"
snippet `(\W)(?<!\\)sup` "sup" wAr
`!p snip.rv=match.group(1)`\sup $0
endsnippet

context "math()"
snippet `(\W)(?<!\\)inf` "inf" wAr
`!p snip.rv=match.group(1)`\inf $0
endsnippet

context "math()"
snippet binom "binom" wA
\binom{$1}{$2}`!p
if t[0] and t[0][0] not in [',',' ','/']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

######## Linear Algebra ########
context "math()"
snippet iprod "inner product" wA
\langle $1 , $2 \rangle`!p
if t[0] and t[0][0] not in [',',' ','/']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

context "math()"
snippet floor "floor" wA
\lfloor $0 \rfloor
endsnippet
